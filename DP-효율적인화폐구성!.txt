#그리디 알고리즘의 거스름돈 변형 문제. 큰 단위가 작은 단위의 배수가 아님!
#전형적인 DP 문제.

#N만큼 입력받은 화폐의 단위를 리스트로 만들고, 0부터 M+1까지 하나씩 확인해가며 최소값을 찾는다. 0부터 M+1까지 각 인덱스를 '금액'으로 고려하여 메모이제이션을 진행한다.
#예를들어, 화폐의 단위가 2일 때, 2는 2-2 = 0일 때 2를 한번 더해서 2가 됨. 4는 2에 2를 더해서 4가 됨. 이런식으로 a(i-k)를 만들 수 있다면 거기에 k(화폐의 단위)를 더해서 ai(0-M+1까지의 금액)를 만들 수 있는 것

N, M = map(int, input().split())
K = []

for _ in range(N):
  K.append(int(input()))

#10001 = INF 값으로 dp 배열 초기화
dp = [10001] * (M+1)  
dp[0] = 0

for i in range(N):
  for j in range(K[i], M+1):
    dp[j] = min(dp[j], dp[j - K[i]]+1)

if dp[M] == 10001:
  print(-1)
else:
  print(dp[M])